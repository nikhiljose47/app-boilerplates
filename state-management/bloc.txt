Core components - Event, State, BLoC, Stream.

1.Intialize
BlocProvider VS 
BlocProvider(
    create: (context) => HomeBloc(),
 .....
)


2.Manager - Events, State, Bloc

2.1 Home Event

abstract/sealed? class CounterEvent {}
class Increment extends CounterEvent {}
class Decrement extends CounterEvent {}


2.2 State
@immutable
sealed class HomeState {}

final class HomeInitial extends HomeState {}

final class CounterState extends HomeState {
  final int counter;
  const CounterState({required this.counter});
}


2.3 Bloc

class CounterBloc extends Bloc<CounterEvent, CounterState> {
  CounterBloc() : super(CounterState(0)) {
    on<Increment>((event, emit) => emit(CounterState(state.count + 1)));
    on<Decrement>((event, emit) => emit(CounterState(state.count - 1)));
  }
}



3.Build function

  final HomeBloc counterBloc = BlocProvider.of<HomeBloc>(context);

    return BlocBuilder<HomeBloc, CounterState>( // Rebuilding the UI based on the current state of HomeBloc
      builder: (context, state) {
        return Scaffold(
            child: Text('Counter: ${state.counter}', 
          ), 
          floatingActionButton: FloatingActionButton(
            onPressed: () {
              counterBloc.add(Increment(counter: state.counter));  // Dispatching an event to increment the counter
            },
          ),
        );
      },
    );


Builder X Listener X Consumer

Widget	Rebuild UI?	Side effects?	Use case
BlocBuilder	✔ Yes	❌ No	UI update only
BlocListener	❌ No	✔ Yes	SideEffects = Snackbars, navigation, dialogs
BlocConsumer	✔ Yes	✔ Yes	SideEffects = When you need both UI + side effects


Signature of the fat boy -  

BlocConsumer<BlocType, StateType>(
  listener: (context, state) {},
  builder: (context, state) => Widget
)
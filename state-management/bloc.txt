Core components - Event, State, BLoC, Stream.

1.Intialize
BlocProvider VS 
BlocProvider(
    create: (context) => HomeBloc(),
 .....
)


2.Manager - Events, State, Bloc

2.1 Home Events
abstract/sealed? class CounterEvent {}
class Increment extends CounterEvent {}
class Decrement extends CounterEvent {}

2.2 Bloc
class CounterBloc extends Bloc<CounterEvent, CounterState> {
  CounterBloc() : super(CounterState(0)) {
    on<Increment>((event, emit) => emit(CounterState(state.count + 1))); //emit - A callback funtion, used to push state or "Add new value to the Blocâ€™s state stream"
    on<Decrement>((event, emit) => emit(CounterState(state.count - 1)));
  }
}

2.3 State - Simple OOP class
@immutable
sealed class HomeState {}

final class HomeInitial extends HomeState {}

final class CounterState extends HomeState {
  final int counter;
  const CounterState({required this.counter});
}


3.Build function

  final HomeBloc counterBloc = BlocProvider.of<HomeBloc>(context);

    return BlocBuilder<HomeBloc, CounterState>( // Rebuilding the UI based on the current state of HomeBloc
      builder: (context, state) {
        return Scaffold(
            child: Text('Counter: ${state.counter}', 
          ), 
          floatingActionButton: FloatingActionButton(
            onPressed: () {
              counterBloc.add(Increment(counter: state.counter));  // Dispatching an event to increment the counter
            },
          ),
        );
      },
    );
OR 

BlocConsumer<BlocType, StateType>(
  listener: (context, state) {},
  builder: (context, state) => Widget
)
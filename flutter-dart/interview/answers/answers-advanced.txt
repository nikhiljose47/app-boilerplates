Senior Engineer = 
1.Senior engineers design for change, not just for “working”. == Design for Change
2.Think & Learn = Syper design the system 


How http to handle?


View (Widget)
 ↓
ViewModel
 ↓
Repository   ← Model layer lives here
 ↓
Network Layer (API calls)

Network/Api layer or client  


Layer = A set of classes with one responsibility == One responsibility
ex: API layer = All HTTP-related logic lives in one place, separate from UI and business logic.



System Design?
For any framework, architecture explains: / how frameworks are checked/performance
Between blocks/global - data flow, Change detection mechanism 
Its rendering technique
Extra - Platfrom inetgration system


Flutter working

Layers - 
1.Framework layer(Dart widgets)
2.C++ Engine layer
3.Embedder layer
4.Skia layer

Note: Rebuilding widgets ≠ repainting (Element decides)

Schema -
1.Create widget tree 
    ↓
(Para)2.Create an element tree for each/reuse  - Have buildcontext, Compare old vs new widgets (Perfo starts)
(Para)3.Create renderObject(Parent of container/cards) Tree - Have sizes, how to paint //Dart work is done  //Real heavy work
    ↓
4.Do layouting and some updates and create paint commands from RenderObjects 
    ↓
5.Converts paint commands set/layer into Skia commands
    ↓
6.Skia convert commands to platform GPU hardware (via platform graphics API)
    
7.Pixels on screen.


How others do?
Angular - Browser DOM
React Native/Xamarin - Platform/JS brigde

Skia, an Open-source 2D graphics library (a mediator b/w real GPU & i/p commands), written in C++
Platform graphics API
OpenGL (Android)
Metal (iOS)
Vulkan (newer Android)
DirectX (Windows)



Event loop flutter

Events - Synchronous, Async, microtasks to do continous and while loop (till end of app) ~A schdeuler?

Requisites:
1.OS - Process Scheduling
2.OS = shedule threads

Flutter = 1 process with threads - 
 UI Thread      -> Runs Dart code + widget build    // Dart code only runs on UI thread(unless you spawn isolates)
 Raster Thread  -> Converts UI to pixels (GPU work) 
 IO Thread      -> File, network, image decode      
 Worker Threads -> Background native work         
 Other..


Schema: 
 while (app is running) { //  A single while loop
  run synchronous code
  run microtasks        //high priority to do next or internal like notifyListeners, ui update code
  run async callbacks   //body in timer/future or .then are callbacks which run after future/timer completes
}



